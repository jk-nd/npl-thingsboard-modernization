package deviceManagementOptimized

/**
 * Smart Device Data Structures with Embedded Validation
 */

/**
 * Validation levels for different use cases
 */
enum ValidationLevel {
    BASIC,
    ENHANCED, 
    STRICT
};

/**
 * Device operation types for state-driven dispatch
 */
enum DeviceOperation {
    MAINTENANCE_REQUEST,
    SECURITY_UPDATE,
    ASSIGNMENT_CHANGE,
    CONFIGURATION_UPDATE
};

/**
 * Enhanced device structure with metadata
 */
struct OptimizedDevice {
    id: Text,
    name: Text,
    type: Text,
    tenantId: Text,
    customerId: Optional<Text>,
    metadata: DeviceMetadata,
    validationLevel: ValidationLevel
};

/**
 * Rich device metadata structure
 */
struct DeviceMetadata {
    tags: Set<Text>,
    attributes: Map<Text, Text>,
    creationContext: CreationContext,
    lastModified: DateTime
};

/**
 * Creation context for audit trail
 */
struct CreationContext {
    createdBy: Text,
    createdAt: DateTime,
    validationLevel: ValidationLevel,
    source: Text
};

/**
 * Batch processing context for functional pipelines
 */
struct BatchProcessingContext {
    validDevices: List<OptimizedDevice>,
    invalidDevices: List<OptimizedDevice>,
    errorDetails: Map<Text, List<Text>>,
    processingMetrics: ProcessingMetrics
};

/**
 * Processing metrics for observability
 */
struct ProcessingMetrics {
    totalProcessed: Number,
    validationTime: Duration,
    processingTime: Duration,
    errorRate: Number
};

/**
 * Enhanced bulk import result
 */
struct OptimizedBulkResult {
    totalProcessed: Number,
    successCount: Number,
    failedCount: Number,
    errors: List<Text>,
    metrics: ProcessingMetrics,
    context: BatchProcessingContext
};

/**
 * Device limits with dynamic configuration
 */
struct DynamicDeviceLimits {
    maxDevicesPerTenant: Number,
    maxDevicesPerCustomer: Number,
    maxDevicesPerProfile: Number,
    scalingFactor: Number,
    lastUpdated: DateTime
};

// ========== SMART DATA FACTORY FUNCTIONS ==========

/**
 * Reserved device names for validation
 */
var RESERVED_NAMES = setOf("admin", "system", "root", "test", "default", "null", "undefined", "device", "sensor");

/**
 * Valid device types
 */
var VALID_DEVICE_TYPES = setOf("sensor", "actuator", "gateway", "controller", "monitor", "tracker");

/**
 * Smart factory function with embedded validation
 */
function createOptimizedDevice(
    id: Text,
    name: Text,
    type: Text,
    tenantId: Text,
    validationLevel: ValidationLevel,
    createdBy: Text
) returns OptimizedDevice -> {
    
    // Basic validation (always applied)
    require(id.length() > 0, "Device ID required");
    require(name.length() >= 3, "Device name must be at least 3 characters");
    require(name.length() <= 255, "Device name cannot exceed 255 characters");
    require(type.length() > 0, "Device type required");
    require(tenantId.length() > 0, "Tenant ID required");
    
    // Enhanced validation
    if (validationLevel == ValidationLevel.ENHANCED || validationLevel == ValidationLevel.STRICT) {
        require(!RESERVED_NAMES.contains(name.toLowerCase()), "Device name is reserved");
        require(VALID_DEVICE_TYPES.contains(type), "Invalid device type");
    };
    
    // Strict validation
    if (validationLevel == ValidationLevel.STRICT) {
        require(name.matches("^[a-zA-Z0-9_-]+$"), "Device name contains invalid characters");
        require(tenantId.matches("^[0-9a-fA-F-]+$"), "Invalid tenant ID format");
    };
    
    return OptimizedDevice(
        id = id,
        name = name,
        type = type,
        tenantId = tenantId,
        customerId = optionalOf<Text>(),
        validationLevel = validationLevel,
        metadata = DeviceMetadata(
            tags = setOf<Text>(),
            attributes = mapOf<Text, Text>(),
            creationContext = CreationContext(
                createdBy = createdBy,
                createdAt = now(),
                validationLevel = validationLevel,
                source = "api"
            ),
            lastModified = now()
        )
    );
};

/**
 * Functional validation pipeline for batch processing
 */
function validateDeviceBatch(
    devices: List<OptimizedDevice>,
    validationLevel: ValidationLevel
) returns BatchProcessingContext -> {
    
    var startTime = now();
    
    var validationResults = devices.map(function(device: OptimizedDevice) -> {
        var errors = listOf<Text>();
        var isValid = true;
        
        // Validate each device
        if (device.name.length() < 3) {
            errors = errors.with("Device name too short");
            isValid = false;
        };
        
        if (device.type.length() == 0) {
            errors = errors.with("Device type required");
            isValid = false;
        };
        
        if (validationLevel != ValidationLevel.BASIC && RESERVED_NAMES.contains(device.name)) {
            errors = errors.with("Reserved device name");
            isValid = false;
        };
        
        return mapOf(
            Pair("device", device),
            Pair("isValid", isValid),
            Pair("errors", errors)
        );
    });
    
    var validDevices = validationResults
        .filter(function(result) -> result.get("isValid"))
        .map(function(result) -> result.get("device"));
    
    var invalidDevices = validationResults
        .filter(function(result) -> !result.get("isValid"))
        .map(function(result) -> result.get("device"));
    
    var errorDetails = validationResults
        .filter(function(result) -> !result.get("isValid"))
        .fold(mapOf<Text, List<Text>>(), function(acc, result) -> 
            acc.with(result.get("device").id, result.get("errors"))
        );
    
    var validationTime = now().durationUntil(startTime);
    var errorRate = if (devices.size() > 0) { invalidDevices.size() / devices.size() } else { 0 };
    
    return BatchProcessingContext(
        validDevices = validDevices,
        invalidDevices = invalidDevices,
        errorDetails = errorDetails,
        processingMetrics = ProcessingMetrics(
            totalProcessed = devices.size(),
            validationTime = validationTime,
            processingTime = validationTime,
            errorRate = errorRate
        )
    );
};

// ========== ADVANCED STATE MACHINE PROTOCOLS ==========

/**
 * Device Lifecycle State Machine
 * Encodes all device lifecycle logic in state transitions
 */
@api
protocol[sys_admin, tenant_admin] DeviceLifecycle(var deviceId: Text) {
    
    initial state draft;
    state validating;
    state provisioning;
    state active;
    state maintenance;
    state updating;
    state suspended;
    final state retired;
    final state deleted;
    
    private var device: Optional<OptimizedDevice> = optionalOf<OptimizedDevice>();
    private var lifecycleHistory = listOf<Text>();
    private var lastStateChange: DateTime = now();
    
    /**
     * Initialize device in draft state
     */
    @api
    permission[sys_admin | tenant_admin] initializeDevice(deviceData: OptimizedDevice) | draft {
        device = optionalOf(deviceData);
        lifecycleHistory = lifecycleHistory.with("Initialized as draft");
        become validating;
    };
    
    /**
     * Validate device - state guard eliminates conditional logic
     */
    @api
    permission[sys_admin | tenant_admin] validateDevice() | validating {
        // State guard ensures we're in validating state - no conditionals needed
        lifecycleHistory = lifecycleHistory.with("Validation completed");
        lastStateChange = now();
        become provisioning;
    };
    
    /**
     * Provision device resources
     */
    @api
    permission[sys_admin | tenant_admin] provisionDevice() | provisioning {
        lifecycleHistory = lifecycleHistory.with("Device provisioned");
        lastStateChange = now();
        become active;
    };
    
    /**
     * Update device - only possible when active
     */
    @api
    permission[sys_admin | tenant_admin] updateDevice(newData: OptimizedDevice) | active {
        device = optionalOf(newData);
        lifecycleHistory = lifecycleHistory.with("Device updated");
        lastStateChange = now();
        become updating;
    };
    
    /**
     * Complete update
     */
    @api
    permission[sys_admin | tenant_admin] completeUpdate() | updating {
        lifecycleHistory = lifecycleHistory.with("Update completed");
        become active;
    };
    
    /**
     * Enter maintenance mode
     */
    @api
    permission[sys_admin | tenant_admin] enterMaintenance() | active {
        lifecycleHistory = lifecycleHistory.with("Entered maintenance");
        become maintenance;
    };
    
    /**
     * Exit maintenance mode
     */
    @api
    permission[sys_admin | tenant_admin] exitMaintenance() | maintenance {
        lifecycleHistory = lifecycleHistory.with("Exited maintenance");
        become active;
    };
    
    /**
     * Suspend device
     */
    @api
    permission[sys_admin | tenant_admin] suspendDevice() | active, maintenance {
        lifecycleHistory = lifecycleHistory.with("Device suspended");
        become suspended;
    };
    
    /**
     * Resume device
     */
    @api
    permission[sys_admin | tenant_admin] resumeDevice() | suspended {
        lifecycleHistory = lifecycleHistory.with("Device resumed");
        become active;
    };
    
    /**
     * Retire device
     */
    @api
    permission[sys_admin | tenant_admin] retireDevice() | active, maintenance, suspended {
        lifecycleHistory = lifecycleHistory.with("Device retired");
        become retired;
    };
    
    /**
     * Delete device permanently
     */
    @api
    permission[sys_admin] deleteDevice() | retired {
        lifecycleHistory = lifecycleHistory.with("Device deleted permanently");
        become deleted;
    };
    
    /**
     * Get current device state and history
     */
    @api
    permission[sys_admin | tenant_admin | customer_user] getDeviceState() returns Map<Text, Text> {
        return mapOf(
            Pair("currentState", activeState().getOrFail().toText()),
            Pair("lastStateChange", lastStateChange.toText()),
            Pair("historyCount", lifecycleHistory.size().toText())
        );
    };
    
    /**
     * Get device data - only when active or maintenance
     */
    @api
    permission[sys_admin | tenant_admin | customer_user] getDeviceData() returns Optional<OptimizedDevice> | active, maintenance {
        return device;
    };
};

/**
 * Multi-Dimensional Device Assignment State Machine
 * Handles orthogonal assignment states
 */
@api
protocol[sys_admin, tenant_admin] DeviceAssignment(var deviceId: Text) {
    
    initial state unassigned;
    state customer_assigned;
    state edge_assigned;
    state dual_assigned;
    state assignment_locked;
    
    private var customerId: Optional<Text> = optionalOf<Text>();
    private var edgeId: Optional<Text> = optionalOf<Text>();
    private var assignmentHistory = listOf<Text>();
    private var lockReason: Optional<Text> = optionalOf<Text>();
    
    /**
     * Assign to customer - state guards eliminate complex conditional logic
     */
    @api
    permission[sys_admin | tenant_admin] assignToCustomer(newCustomerId: Text) | unassigned, edge_assigned {
        require(newCustomerId.length() > 0, "Customer ID required");
        
        customerId = optionalOf(newCustomerId);
        assignmentHistory = assignmentHistory.with("Assigned to customer: " + newCustomerId);
        
        if (activeState().getOrFail() == States.edge_assigned) {
            become dual_assigned;
        } else {
            become customer_assigned;
        };
    };
    
    /**
     * Assign to edge
     */
    @api
    permission[sys_admin | tenant_admin] assignToEdge(newEdgeId: Text) | unassigned, customer_assigned {
        require(newEdgeId.length() > 0, "Edge ID required");
        
        edgeId = optionalOf(newEdgeId);
        assignmentHistory = assignmentHistory.with("Assigned to edge: " + newEdgeId);
        
        if (activeState().getOrFail() == States.customer_assigned) {
            become dual_assigned;
        } else {
            become edge_assigned;
        };
    };
    
    /**
     * Unassign from customer
     */
    @api
    permission[sys_admin | tenant_admin] unassignFromCustomer() | customer_assigned, dual_assigned {
        var oldCustomerId = customerId.getOrFail();
        customerId = optionalOf<Text>();
        assignmentHistory = assignmentHistory.with("Unassigned from customer: " + oldCustomerId);
        
        if (activeState().getOrFail() == States.dual_assigned) {
            become edge_assigned;
        } else {
            become unassigned;
        };
    };
    
    /**
     * Unassign from edge
     */
    @api
    permission[sys_admin | tenant_admin] unassignFromEdge() | edge_assigned, dual_assigned {
        var oldEdgeId = edgeId.getOrFail();
        edgeId = optionalOf<Text>();
        assignmentHistory = assignmentHistory.with("Unassigned from edge: " + oldEdgeId);
        
        if (activeState().getOrFail() == States.dual_assigned) {
            become customer_assigned;
        } else {
            become unassigned;
        };
    };
    
    /**
     * Lock assignments to prevent changes
     */
    @api
    permission[sys_admin] lockAssignments(reason: Text) | customer_assigned, edge_assigned, dual_assigned {
        lockReason = optionalOf(reason);
        assignmentHistory = assignmentHistory.with("Assignments locked: " + reason);
        become assignment_locked;
    };
    
    /**
     * Unlock assignments
     */
    @api
    permission[sys_admin] unlockAssignments() | assignment_locked {
        var reason = lockReason.getOrElse("Unknown");
        lockReason = optionalOf<Text>();
        assignmentHistory = assignmentHistory.with("Assignments unlocked (was: " + reason + ")");
        
        // Return to appropriate state based on assignments
        if (customerId.isPresent() && edgeId.isPresent()) {
            become dual_assigned;
        } else if (customerId.isPresent()) {
            become customer_assigned;
        } else if (edgeId.isPresent()) {
            become edge_assigned;
        } else {
            become unassigned;
        };
    };
    
    /**
     * Get assignment information
     */
    @api
    permission[sys_admin | tenant_admin | customer_user] getAssignments() returns Map<Text, Optional<Text>> {
        return mapOf(
            Pair("customerId", customerId),
            Pair("edgeId", edgeId),
            Pair("lockReason", lockReason)
        );
    };
};

/**
 * Device Security State Machine
 * Manages authentication and security lifecycle
 */
@api
protocol[sys_admin, tenant_admin] DeviceSecurity(var deviceId: Text) {
    
    initial state credentials_pending;
    state credentials_active;
    state credentials_rotating;
    state credentials_expired;
    state security_locked;
    state security_compromised;
    
    private var credentialsType: Text = "ACCESS_TOKEN";
    private var credentialsId: Text = "";
    private var credentialsValue: Text = "";
    private var credentialsExpiry: Optional<DateTime> = optionalOf<DateTime>();
    private var securityEvents = listOf<Text>();
    private var lockReason: Optional<Text> = optionalOf<Text>();
    
    init {
        credentialsId = "device_" + deviceId;
        credentialsValue = generateSecureToken(deviceId);
        securityEvents = securityEvents.with("Security context initialized");
    };
    
    /**
     * Activate credentials
     */
    @api
    permission[sys_admin | tenant_admin] activateCredentials() | credentials_pending {
        credentialsExpiry = optionalOf(now().plus(days(30)));
        securityEvents = securityEvents.with("Credentials activated");
        become credentials_active;
    };
    
    /**
     * Rotate credentials
     */
    @api
    permission[sys_admin | tenant_admin] rotateCredentials() | credentials_active, credentials_expired {
        securityEvents = securityEvents.with("Credential rotation started");
        become credentials_rotating;
    };
    
    /**
     * Complete credential rotation
     */
    @api
    permission[sys_admin | tenant_admin] completeRotation(newCredentialsValue: Text) | credentials_rotating {
        require(newCredentialsValue.length() > 0, "New credentials value required");
        
        credentialsValue = newCredentialsValue;
        credentialsExpiry = optionalOf(now().plus(days(30)));
        securityEvents = securityEvents.with("Credential rotation completed");
        become credentials_active;
    };
    
    /**
     * Mark credentials as expired
     */
    @api
    permission[sys_admin | tenant_admin] expireCredentials() | credentials_active {
        securityEvents = securityEvents.with("Credentials expired");
        become credentials_expired;
    };
    
    /**
     * Lock security due to suspicious activity
     */
    @api
    permission[sys_admin | tenant_admin] lockSecurity(reason: Text) | credentials_active, credentials_expired {
        lockReason = optionalOf(reason);
        securityEvents = securityEvents.with("Security locked: " + reason);
        become security_locked;
    };
    
    /**
     * Mark as compromised
     */
    @api
    permission[sys_admin] markAsCompromised(reason: Text) | credentials_active, credentials_expired, security_locked {
        lockReason = optionalOf(reason);
        securityEvents = securityEvents.with("Security compromised: " + reason);
        become security_compromised;
    };
    
    /**
     * Unlock security and reset credentials
     */
    @api
    permission[sys_admin] unlockAndReset() | security_locked, security_compromised {
        credentialsValue = generateSecureToken(deviceId);
        credentialsExpiry = optionalOf(now().plus(days(30)));
        lockReason = optionalOf<Text>();
        securityEvents = securityEvents.with("Security unlocked and credentials reset");
        become credentials_active;
    };
    
    /**
     * Get security status
     */
    @api
    permission[sys_admin | tenant_admin] getSecurityStatus() returns Map<Text, Text> {
        return mapOf(
            Pair("securityState", activeState().getOrFail().toText()),
            Pair("credentialsType", credentialsType),
            Pair("credentialsId", credentialsId),
            Pair("eventCount", securityEvents.size().toText())
        );
    };
    
    /**
     * Get credentials (only when active)
     */
    @api
    permission[sys_admin | tenant_admin] getCredentialsValue() returns Text | credentials_active {
        return credentialsValue;
    };
    
    /**
     * Helper function to generate secure tokens
     */
    function generateSecureToken(deviceId: Text) returns Text -> {
        return "secure_token_" + deviceId + "_" + now().toText();
    };
};

// ========== INTERNAL ORCHESTRATION PROTOCOL ==========

/**
 * Internal device metadata management (not exposed to API)
 */
protocol DeviceMetadataManager(var deviceId: Text) {
    
    initial state collecting;
    state validating;
    state enriched;
    
    private var tags = setOf<Text>();
    private var attributes = mapOf<Text, Text>();
    private var enrichmentData = mapOf<Text, Text>();
    
    /**
     * Add metadata tag
     */
    function addTag(tag: Text) | collecting {
        require(tag.length() > 0, "Tag cannot be empty");
        tags = tags.with(tag);
    };
    
    /**
     * Add metadata attribute
     */
    function addAttribute(key: Text, value: Text) | collecting {
        require(key.length() > 0, "Attribute key required");
        attributes = attributes.with(key, value);
    };
    
    /**
     * Validate metadata completeness
     */
    function validateMetadata() | collecting {
        require(tags.size() > 0, "At least one tag required");
        become validating;
    };
    
    /**
     * Enrich with external data
     */
    function enrichWithExternalData() | validating {
        // Simulate enrichment with external data sources
        enrichmentData = enrichmentData.with("enriched_at", now().toText());
        enrichmentData = enrichmentData.with("enrichment_source", "external_api");
        become enriched;
    };
    
    /**
     * Get complete metadata
     */
    function getCompleteMetadata() returns DeviceMetadata | enriched {
        return DeviceMetadata(
            tags = tags,
            attributes = attributes.plus(enrichmentData),
            creationContext = CreationContext(
                createdBy = "system",
                createdAt = now(),
                validationLevel = ValidationLevel.ENHANCED,
                source = "metadata_manager"
            ),
            lastModified = now()
        );
    };
};

// ========== MAIN ORCHESTRATION PROTOCOL ==========

/**
 * Device Context - encapsulates all device-related protocols
 */
struct DeviceContext {
    lifecycle: DeviceLifecycle,
    assignment: DeviceAssignment,
    security: DeviceSecurity,
    metadataManager: DeviceMetadataManager
};

/**
 * Main Optimized Device Management Protocol
 * Demonstrates hierarchical protocol composition and state-driven orchestration
 */
@api
protocol[sys_admin, tenant_admin, customer_user] OptimizedDeviceManagement() {
    
    initial state initializing;
    state operational;
    state maintenance_mode;
    state scaling_mode;
    
    // Core device storage with context encapsulation
    private var deviceContexts = mapOf<Text, DeviceContext>();
    private var deviceLimits = DynamicDeviceLimits(
        maxDevicesPerTenant = 10000,
        maxDevicesPerCustomer = 1000,
        maxDevicesPerProfile = 5000,
        scalingFactor = 1.0,
        lastUpdated = now()
    );
    
    // Operational metrics
    private var operationalMetrics = mapOf<Text, Number>();
    
    init {
        operationalMetrics = operationalMetrics.with("devices_created", 0);
        operationalMetrics = operationalMetrics.with("devices_active", 0);
        operationalMetrics = operationalMetrics.with("operations_performed", 0);
        become operational;
    };
    
    /**
     * Enhanced device creation with full context orchestration
     */
    @api
    permission[sys_admin | tenant_admin] createOptimizedDevice(
        id: Text,
        name: Text,
        type: Text,
        tenantId: Text,
        validationLevel: ValidationLevel
    ) returns OptimizedDevice | operational {
        
        // Create validated device using smart factory
        var device = createOptimizedDevice(id, name, type, tenantId, validationLevel, "api_user");
        
        // Create nested protocol hierarchy with full encapsulation
        var lifecycle = DeviceLifecycle[sys_admin, tenant_admin](id);
        var assignment = DeviceAssignment[sys_admin, tenant_admin](id);
        var security = DeviceSecurity[sys_admin, tenant_admin](id);
        var metadataManager = DeviceMetadataManager(id);
        
        // Orchestrate creation workflow through state transitions
        lifecycle.initializeDevice[sys_admin](device);
        lifecycle.validateDevice[sys_admin]();
        security.activateCredentials[sys_admin]();
        
        // Enrich metadata through internal protocol
        metadataManager.addTag("new_device");
        metadataManager.addTag(type);
        metadataManager.addAttribute("tenant", tenantId);
        metadataManager.addAttribute("created_via", "optimized_api");
        metadataManager.validateMetadata();
        metadataManager.enrichWithExternalData();
        
        lifecycle.provisionDevice[sys_admin]();
        
        // Create complete device context
        var context = DeviceContext(
            lifecycle = lifecycle,
            assignment = assignment,
            security = security,
            metadataManager = metadataManager
        );
        
        deviceContexts = deviceContexts.with(id, context);
        
        // Update operational metrics
        var currentCount = operationalMetrics.getOrElse("devices_created", 0);
        operationalMetrics = operationalMetrics.with("devices_created", currentCount + 1);
        
        notify deviceSaved(device);
        return device;
    };
    
    /**
     * State-aware complex device operations with automated orchestration
     */
    @api
    permission[sys_admin | tenant_admin] performComplexOperation(
        deviceId: Text,
        operation: DeviceOperation,
        parameters: Map<Text, Text>
    ) | operational {
        
        var context = deviceContexts.getOrFail(deviceId);
        
        // State-driven operation dispatch - no manual conditionals
        match(operation) {
            MAINTENANCE_REQUEST -> {
                context.security.lockSecurity[sys_admin]("maintenance_mode");
                context.lifecycle.enterMaintenance[sys_admin]();
            }
            SECURITY_UPDATE -> {
                context.security.rotateCredentials[sys_admin]();
                var newCredentials = parameters.getOrElse("new_credentials", "auto_generated");
                context.security.completeRotation[sys_admin](newCredentials);
            }
            ASSIGNMENT_CHANGE -> {
                var customerId = parameters.getOrElse("customer_id", "");
                if (customerId.length() > 0) {
                    context.assignment.assignToCustomer[sys_admin](customerId);
                };
            }
            CONFIGURATION_UPDATE -> {
                var deviceData = context.lifecycle.getDeviceData[sys_admin]().getOrFail();
                context.lifecycle.updateDevice[sys_admin](deviceData);
                context.lifecycle.completeUpdate[sys_admin]();
            }
        };
        
        // Update operational metrics
        var currentOps = operationalMetrics.getOrElse("operations_performed", 0);
        operationalMetrics = operationalMetrics.with("operations_performed", currentOps + 1);
    };
    
    /**
     * Functional bulk operations with advanced pipeline processing
     */
    @api
    permission[sys_admin | tenant_admin] bulkCreateOptimizedDevices(
        deviceSpecs: List<Map<Text, Text>>,
        validationLevel: ValidationLevel
    ) returns OptimizedBulkResult | operational {
        
        var startTime = now();
        
        // Transform specifications to devices using functional pipeline
        var devices = deviceSpecs.map(function(spec: Map<Text, Text>) -> 
            createOptimizedDevice(
                spec.getOrElse("id", ""),
                spec.getOrElse("name", ""),
                spec.getOrElse("type", ""),
                spec.getOrElse("tenantId", ""),
                validationLevel,
                "bulk_api"
            )
        );
        
        // Process through validation pipeline
        var context = validateDeviceBatch(devices, validationLevel);
        
        // Create device contexts for valid devices using functional composition
        var createdDevices = context.validDevices.map(function(device: OptimizedDevice) -> {
            // Create protocols for each valid device
            var lifecycle = DeviceLifecycle[sys_admin, tenant_admin](device.id);
            var assignment = DeviceAssignment[sys_admin, tenant_admin](device.id);
            var security = DeviceSecurity[sys_admin, tenant_admin](device.id);
            var metadataManager = DeviceMetadataManager(device.id);
            
            // Orchestrate creation
            lifecycle.initializeDevice[sys_admin](device);
            lifecycle.validateDevice[sys_admin]();
            security.activateCredentials[sys_admin]();
            lifecycle.provisionDevice[sys_admin]();
            
            var deviceContext = DeviceContext(
                lifecycle = lifecycle,
                assignment = assignment,
                security = security,
                metadataManager = metadataManager
            );
            
            deviceContexts = deviceContexts.with(device.id, deviceContext);
            notify deviceSaved(device);
            
            return device;
        });
        
        var processingTime = now().durationUntil(startTime);
        
        // Update metrics
        var currentCount = operationalMetrics.getOrElse("devices_created", 0);
        operationalMetrics = operationalMetrics.with("devices_created", currentCount + createdDevices.size());
        
        return OptimizedBulkResult(
            totalProcessed = deviceSpecs.size(),
            successCount = createdDevices.size(),
            failedCount = context.invalidDevices.size(),
            errors = context.errorDetails.values().flatMap(function(errs: List<Text>) -> errs),
            metrics = ProcessingMetrics(
                totalProcessed = deviceSpecs.size(),
                validationTime = context.processingMetrics.validationTime,
                processingTime = processingTime,
                errorRate = context.processingMetrics.errorRate
            ),
            context = context
        );
    };
    
    /**
     * Get device with full context information
     */
    @api
    permission[sys_admin | tenant_admin | customer_user] getDeviceWithContext(deviceId: Text) returns Optional<Map<Text, Text>> | operational {
        var context = deviceContexts.getOrNone(deviceId);
        
        if (context.isPresent()) {
            var deviceContext = context.getOrFail();
            var deviceState = deviceContext.lifecycle.getDeviceState[sys_admin]();
            var securityStatus = deviceContext.security.getSecurityStatus[sys_admin]();
            var assignments = deviceContext.assignment.getAssignments[sys_admin]();
            
            return optionalOf(deviceState.plus(securityStatus).plus(assignments));
        };
        
        return optionalOf<Map<Text, Text>>();
    };
    
    /**
     * Get operational metrics
     */
    @api
    permission[sys_admin | tenant_admin] getOperationalMetrics() returns Map<Text, Number> | operational {
        return operationalMetrics;
    };
    
    /**
     * Dynamic scaling mode for high-volume operations
     */
    @api
    permission[sys_admin] enterScalingMode(scalingFactor: Number) | operational {
        require(scalingFactor > 0, "Scaling factor must be positive");
        
        deviceLimits = DynamicDeviceLimits(
            maxDevicesPerTenant = (deviceLimits.maxDevicesPerTenant * scalingFactor).toNumber(),
            maxDevicesPerCustomer = (deviceLimits.maxDevicesPerCustomer * scalingFactor).toNumber(),
            maxDevicesPerProfile = (deviceLimits.maxDevicesPerProfile * scalingFactor).toNumber(),
            scalingFactor = scalingFactor,
            lastUpdated = now()
        );
        
        become scaling_mode;
    };
    
    /**
     * Exit scaling mode
     */
    @api
    permission[sys_admin] exitScalingMode() | scaling_mode {
        deviceLimits = DynamicDeviceLimits(
            maxDevicesPerTenant = 10000,
            maxDevicesPerCustomer = 1000,
            maxDevicesPerProfile = 5000,
            scalingFactor = 1.0,
            lastUpdated = now()
        );
        
        become operational;
    };
    
    /**
     * Get all device contexts (administrative function)
     */
    @api
    permission[sys_admin] getAllDeviceContexts() returns List<Text> | operational, scaling_mode {
        return deviceContexts.keys().asList();
    };
};

// ========== NOTIFICATIONS ==========

notification deviceSaved(device: OptimizedDevice) returns Unit;
notification deviceOperationCompleted(deviceId: Text, operation: DeviceOperation) returns Unit;
notification bulkOperationCompleted(result: OptimizedBulkResult) returns Unit;
notification deviceStateChanged(deviceId: Text, oldState: Text, newState: Text) returns Unit;
notification securityEventOccurred(deviceId: Text, eventType: Text, details: Text) returns Unit; 