package deviceManagement

/**
 * Represents a device in the system.
 */
struct Device {
    id: Text,
    name: Text,
    type: Text,
    tenantId: Text,
    customerId: Optional<Text>,
    credentials: Text,
    label: Optional<Text>,
    deviceProfileId: Optional<Text>,
    firmwareId: Optional<Text>,
    softwareId: Optional<Text>,
    externalId: Optional<Text>,
    version: Optional<Number>,
    additionalInfo: Optional<Text>,
    createdTime: Optional<Number>,
    deviceData: Optional<Text>
};

/**
 * Device credentials information
 */
struct DeviceCredentials {
    deviceId: Text,
    credentialsType: Text,
    credentialsId: Text,
    credentialsValue: Text,
    expirationTime: Optional<Number>,
    autoRotate: Optional<Boolean>
};

/**
 * Enhanced bulk import result with detailed reporting
 */
struct BulkImportResult {
    totalProcessed: Number,
    successCount: Number,
    failedCount: Number,
    skippedCount: Number,
    errors: List<Text>,
    warnings: List<Text>,
    importId: Text,
    processingTime: Number
};

/**
 * Bulk update request structure
 */
struct DeviceUpdateSet {
    label: Optional<Text>,
    type: Optional<Text>,
    deviceProfileId: Optional<Text>,
    additionalInfo: Optional<Text>
};

/**
 * Validation result structure
 */
struct ValidationResult {
    isValid: Boolean,
    errors: List<Text>,
    warnings: List<Text>
};

/**
 * Device operation result for bulk operations
 */
struct DeviceOperationResult {
    deviceId: Text,
    deviceName: Text,
    success: Boolean,
    errors: List<Text>
};

/**
 * Bulk import progress status
 */
struct BulkImportStatus {
    importId: Text,
    currentState: Text,
    totalItems: Number,
    processedItems: Number,
    successCount: Number,
    failedCount: Number,
    currentItem: Optional<Text>,
    errors: List<Text>,
    progressPercentage: Number,
    elapsedTime: Number,
    estimatedTimeRemaining: Number
};

/**
 * Device limit configuration
 */
struct DeviceLimits {
    maxDevicesPerTenant: Number,
    maxDevicesPerCustomer: Number,
    maxDevicesPerProfile: Number
};

/**
 * Device creation request with credentials
 */
struct SaveDeviceWithCredentialsRequest {
    device: Device,
    credentials: DeviceCredentials
};

/**
 * Enhanced notifications for advanced features
 */
notification deviceSaved(device: Device) returns Unit;
notification deviceDeleted(deviceId: Text) returns Unit;
notification deviceCredentialsUpdated(deviceId: Text, credentials: Text) returns Unit;
notification deviceCredentialsDeleted(deviceId: Text) returns Unit;
notification deviceCredentialsRotated(deviceId: Text, oldCredentials: Text, newCredentials: Text) returns Unit;
notification deviceAssigned(deviceId: Text, customerId: Text) returns Unit;
notification deviceUnassigned(deviceId: Text) returns Unit;
notification deviceClaimed(deviceId: Text, claimedBy: Text) returns Unit;
notification deviceReclaimed(deviceId: Text, reclaimedBy: Text) returns Unit;
notification deviceAssignedToEdge(deviceId: Text, edgeId: Text) returns Unit;
notification deviceUnassignedFromEdge(deviceId: Text, edgeId: Text) returns Unit;
notification devicesBulkImported(importedCount: Number, failedCount: Number, importId: Text) returns Unit;
notification devicesBulkDeleted(deletedCount: Number, failedCount: Number) returns Unit;
notification devicesBulkUpdated(updatedCount: Number, failedCount: Number) returns Unit;
notification deviceValidationFailed(deviceId: Text, errors: List<Text>) returns Unit;
notification deviceLimitExceeded(tenantId: Text, limitType: Text, currentCount: Number, maxCount: Number) returns Unit;
notification bulkImportStarted(importId: Text) returns Unit;
notification bulkImportInitialized(importId: Text, totalItems: Number) returns Unit;
notification bulkImportValidationStarted(importId: Text) returns Unit;
notification bulkImportProcessingStarted(importId: Text) returns Unit;
notification bulkImportProgressUpdated(importId: Text, processed: Number, total: Number, success: Boolean) returns Unit;
notification bulkImportCompleted(importId: Text, successCount: Number, failedCount: Number) returns Unit;
notification bulkImportFailed(importId: Text, reason: Text) returns Unit;

// ========== ADVANCED VALIDATION PROTOCOL ==========

/**
 * Advanced Device Validation Protocol
 * Comprehensive validation rules for device management
 */
@api
protocol[sys_admin, tenant_admin] DeviceValidationRules() {
    
    initial state active;
    
    private var deviceLimits = DeviceLimits(
        maxDevicesPerTenant = 10000,
        maxDevicesPerCustomer = 1000,
        maxDevicesPerProfile = 5000
    );
    
    private var reservedNames = setOf("admin", "system", "root", "test");
    private var allowedDeviceTypes = setOf("sensor", "actuator", "gateway", "controller", "meter", "tracker");
    
    /**
     * Validate device name uniqueness and constraints
     */
    @api
    permission[sys_admin | tenant_admin] validateDeviceName(name: Text, tenantId: Text, excludeDeviceId: Optional<Text>) returns ValidationResult | active {
        var errors = listOf<Text>();
        var warnings = listOf<Text>();
        
        // Check name length
        if (name.length() < 3) {
            errors = errors.with("Device name must be at least 3 characters long");
        };
        
        if (name.length() > 255) {
            errors = errors.with("Device name cannot exceed 255 characters");
        };
        
        // Check reserved names
        if (reservedNames.contains(name)) {
            errors = errors.with("Device name '" + name + "' is reserved and cannot be used");
        };
        
        // Check name pattern (simplified validation)
        if (!isValidDeviceName(name)) {
            errors = errors.with("Device name can only contain letters, numbers, hyphens, and underscores");
        };
        
        return ValidationResult(
            isValid = errors.isEmpty(),
            errors = errors,
            warnings = warnings
        );
    };
    
    /**
     * Validate device limits per tenant/customer
     */
    @api
    permission[sys_admin | tenant_admin] validateDeviceLimits(
        tenantId: Text, 
        customerId: Optional<Text>, 
        deviceProfileId: Optional<Text>,
        currentDeviceCount: Number
    ) returns ValidationResult | active {
        var errors = listOf<Text>();
        var warnings = listOf<Text>();
        
        // Check tenant limits
        if (currentDeviceCount >= deviceLimits.maxDevicesPerTenant) {
            errors = errors.with("Tenant device limit exceeded. Maximum: " + deviceLimits.maxDevicesPerTenant.toText());
        };
        
        // Check customer limits if applicable
        if (customerId.isPresent()) {
            if (currentDeviceCount >= deviceLimits.maxDevicesPerCustomer) {
                errors = errors.with("Customer device limit exceeded. Maximum: " + deviceLimits.maxDevicesPerCustomer.toText());
            };
        };
        
        // Warning when approaching limits
        var warningThreshold = deviceLimits.maxDevicesPerTenant * 80 / 100;
        if (currentDeviceCount > warningThreshold) {
            warnings = warnings.with("Approaching tenant device limit (" + currentDeviceCount.toText() + "/" + deviceLimits.maxDevicesPerTenant.toText() + ")");
        };
        
        return ValidationResult(
            isValid = errors.isEmpty(),
            errors = errors,
            warnings = warnings
        );
    };
    
    /**
     * Validate device type
     */
    @api
    permission[sys_admin | tenant_admin] validateDeviceType(deviceType: Text) returns ValidationResult | active {
        var errors = listOf<Text>();
        var warnings = listOf<Text>();
        
        if (deviceType.length() == 0) {
            errors = errors.with("Device type cannot be empty");
        };
        
        if (!allowedDeviceTypes.contains(deviceType)) {
            warnings = warnings.with("Device type '" + deviceType + "' is not in the standard list of types");
        };
        
        return ValidationResult(
            isValid = errors.isEmpty(),
            errors = errors,
            warnings = warnings
        );
    };
    
    /**
     * Comprehensive device validation
     */
    @api
    permission[sys_admin | tenant_admin] validateDevice(
        device: Device, 
        operation: Text,
        currentDeviceCount: Number
    ) returns ValidationResult | active {
        var allErrors = listOf<Text>();
        var allWarnings = listOf<Text>();
        
        // Validate name
        var nameValidation = this.validateDeviceName[sys_admin](device.name, device.tenantId, optionalOf(device.id));
        for (error in nameValidation.errors) {
            allErrors = allErrors.with(error);
        };
        for (warning in nameValidation.warnings) {
            allWarnings = allWarnings.with(warning);
        };
        
        // Validate type
        var typeValidation = this.validateDeviceType[sys_admin](device.type);
        for (error in typeValidation.errors) {
            allErrors = allErrors.with(error);
        };
        for (warning in typeValidation.warnings) {
            allWarnings = allWarnings.with(warning);
        };
        
        // Validate limits for new devices
        if (operation == "CREATE") {
            var limitsValidation = this.validateDeviceLimits[sys_admin](device.tenantId, device.customerId, device.deviceProfileId, currentDeviceCount);
            for (error in limitsValidation.errors) {
                allErrors = allErrors.with(error);
            };
            for (warning in limitsValidation.warnings) {
                allWarnings = allWarnings.with(warning);
            };
        };
        
        return ValidationResult(
            isValid = allErrors.isEmpty(),
            errors = allErrors,
            warnings = allWarnings
        );
    };
    
    /**
     * Update device limits configuration
     */
    @api
    permission[sys_admin] updateDeviceLimits(newLimits: DeviceLimits) | active {
        deviceLimits = newLimits;
    };
    
    /**
     * Get current device limits
     */
    @api
    permission[sys_admin | tenant_admin] getDeviceLimits() returns DeviceLimits | active {
        return deviceLimits;
    };
    
    // Helper function for name validation
    function isValidDeviceName(name: Text) returns Boolean -> {
        // Simplified validation - in real implementation would use regex
        return name.length() > 0 && name.length() <= 255;
    };
};

// ========== BULK IMPORT PROGRESS PROTOCOL ==========

/**
 * Bulk Import Progress Protocol
 * Manages the lifecycle and progress of bulk operations using NPL states
 */
@api
protocol[sys_admin, tenant_admin] BulkImportProgress(var importId: Text) {
    
    initial state queued;
    state parsing;
    state validating;
    state processing;
    final state completed;
    final state failed;
    
    private var totalItems: Number = 0;
    private var processedItems: Number = 0;
    private var successCount: Number = 0;
    private var failedCount: Number = 0;
    private var currentItem: Optional<Text> = optionalOf<Text>();
    private var errors: List<Text> = listOf<Text>();
    private var startTime: Number = 0;
    
    init {
        startTime = 1234567890; // Simplified for now
        notify bulkImportStarted(importId);
    };
    
    /**
     * Initialize bulk import with total count
     */
    @api
    permission[sys_admin | tenant_admin] initializeImport(total: Number) | queued {
        totalItems = total;
        become parsing;
        notify bulkImportInitialized(importId, total);
    };
    
    /**
     * Start validation phase
     */
    @api
    permission[sys_admin | tenant_admin] startValidation() | parsing {
        become validating;
        notify bulkImportValidationStarted(importId);
    };
    
    /**
     * Start processing phase
     */
    @api
    permission[sys_admin | tenant_admin] startProcessing() | validating {
        become processing;
        notify bulkImportProcessingStarted(importId);
    };
    
    /**
     * Update progress for current item
     */
    @api
    permission[sys_admin | tenant_admin] updateProgress(
        itemName: Text,
        success: Boolean,
        error: Optional<Text>
    ) | processing {
        currentItem = optionalOf(itemName);
        processedItems = processedItems + 1;
        
        if (success) {
            successCount = successCount + 1;
        } else {
            failedCount = failedCount + 1;
            if (error.isPresent()) {
                errors = errors.with(error.getOrFail());
            };
        };
        
        notify bulkImportProgressUpdated(importId, processedItems, totalItems, success);
        
        // Auto-complete when all items processed
        if (processedItems >= totalItems) {
            become completed;
            notify bulkImportCompleted(importId, successCount, failedCount);
        };
    };
    
    /**
     * Mark import as failed
     */
    @api
    permission[sys_admin | tenant_admin] markFailed(reason: Text) | queued, parsing, validating, processing {
        errors = errors.with(reason);
        become failed;
        notify bulkImportFailed(importId, reason);
    };
    
    /**
     * Get current progress
     */
    @api
    permission[sys_admin | tenant_admin] getProgress() returns BulkImportStatus | queued, parsing, validating, processing, completed, failed {
        return BulkImportStatus(
            importId = importId,
            currentState = activeState().getOrFail().toText(),
            totalItems = totalItems,
            processedItems = processedItems,
            successCount = successCount,
            failedCount = failedCount,
            currentItem = currentItem,
            errors = errors,
            progressPercentage = calculateProgressPercentage(),
            elapsedTime = 1000, // Simplified for now  
            estimatedTimeRemaining = calculateEstimatedTime()
        );
    };
    
    // Helper functions
    function calculateProgressPercentage() returns Number -> {
        if (totalItems == 0) {
            return 0;
        };
        return (processedItems * 100) / totalItems;
    };
    
    function calculateEstimatedTime() returns Number -> {
        if (processedItems == 0) {
            return 0;
        };
        // Simplified calculation to avoid type issues
        var remainingItems = totalItems - processedItems;
        return remainingItems * 100; // Simplified estimate
    };
};

// ========== DEVICE-SPECIFIC COMPOSED PROTOCOLS ==========

/**
 * Enhanced Device Credentials Management Protocol
 * Advanced security features including rotation, expiration, and policies
 */
@api
protocol[sys_admin, tenant_admin] DeviceCredentialsManager(var deviceId: Text) {
    
    initial state active;
    state rotating;
    state expired;
    final state deleted;
    
    private var credentialsType: Text = "ACCESS_TOKEN";
    private var credentialsId: Text = "";
    private var credentialsValue: Text = "";
    private var expirationTime: Optional<Number> = optionalOf<Number>();
    private var autoRotate: Boolean = false;
    private var rotationIntervalDays: Number = 90;
    private var previousCredentials: List<Text> = listOf<Text>();
    
    init {
        // Generate default credentials
        credentialsId = "device_" + deviceId;
        credentialsValue = generateSecureToken();
    };
    
    /**
     * Update device credentials with advanced options
     */
    @api
    permission[sys_admin | tenant_admin] updateCredentials(
        newType: Text, 
        newId: Text, 
        newValue: Text,
        expirationDays: Optional<Number>,
        enableAutoRotation: Boolean
    ) | active {
        require(newType.length() > 0, "Credentials type cannot be empty");
        require(newValue.length() > 0, "Credentials value cannot be empty");
        
        // Store previous credentials for rotation history
        if (credentialsValue.length() > 0) {
            previousCredentials = previousCredentials.with(credentialsValue).takeLast(5);
        };
        
        credentialsType = newType;
        credentialsId = newId;
        credentialsValue = newValue;
        autoRotate = enableAutoRotation;
        
        // Set expiration if specified
        if (expirationDays.isPresent()) {
            expirationTime = optionalOf(1234567890 + (expirationDays.getOrFail() * 86400));
        } else {
            expirationTime = optionalOf<Number>();
        };
        
        notify deviceCredentialsUpdated(deviceId, credentialsId);
    };
    
    /**
     * Rotate credentials with validation period
     */
    @api
    permission[sys_admin | tenant_admin] rotateCredentials(validationPeriodHours: Number) | active {
        become rotating;
        
        var oldCredentials = credentialsValue;
        var newCredentials = generateSecureToken();
        
        // Store old credentials temporarily
        previousCredentials = previousCredentials.with(oldCredentials).takeLast(5);
        credentialsValue = newCredentials;
        
        // Set new expiration if auto-rotate is enabled
        if (autoRotate) {
            expirationTime = optionalOf(1234567890 + (rotationIntervalDays * 86400));
        };
        
        notify deviceCredentialsRotated(deviceId, oldCredentials, newCredentials);
    };
    
    /**
     * Configure credential expiration and rotation policy
     */
    @api
    permission[sys_admin | tenant_admin] configureCredentialPolicy(
        expirationDays: Number,
        enableAutoRotation: Boolean,
        rotationInterval: Number
    ) | active {
        autoRotate = enableAutoRotation;
        rotationIntervalDays = rotationInterval;
        
        if (expirationDays > 0) {
            expirationTime = optionalOf(1234567890 + (expirationDays * 86400));
        };
    };
    
    /**
     * Check if credentials are expired
     */
    @api
    permission[sys_admin | tenant_admin] checkCredentialExpiration() returns Boolean | active {
        if (expirationTime.isPresent()) {
            return 1234567890 > expirationTime.getOrFail();
        };
        return false;
    };
    
    /**
     * Get credentials with security info
     */
    @api
    permission[sys_admin | tenant_admin] getCredentialsWithSecurity() returns DeviceCredentials | active {
        return DeviceCredentials(
            deviceId = deviceId,
            credentialsType = credentialsType,
            credentialsId = credentialsId,
            credentialsValue = credentialsValue,
            expirationTime = expirationTime,
            autoRotate = optionalOf(autoRotate)
        );
    };
    
    /**
     * Get current credentials (original method preserved)
     */
    @api
    permission[sys_admin | tenant_admin] getCredentials() returns DeviceCredentials | active {
        return DeviceCredentials(
            deviceId = deviceId,
            credentialsType = credentialsType,
            credentialsId = credentialsId,
            credentialsValue = credentialsValue,
            expirationTime = optionalOf<Number>(),
            autoRotate = optionalOf(false)
        );
    };
    
    /**
     * Delete credentials
     */
    @api
    permission[sys_admin | tenant_admin] deleteCredentials() | active {
        credentialsType = "";
        credentialsId = "";
        credentialsValue = "";
        expirationTime = optionalOf<Number>();
        
        notify deviceCredentialsDeleted(deviceId);
        become deleted;
    };
    
    /**
     * Get credentials value for device record
     */
    @api
    permission[sys_admin | tenant_admin] getCredentialsValue() returns Text | active {
        return credentialsValue;
    };
    
    // Helper function to generate secure tokens
    function generateSecureToken() returns Text -> {
        // In real implementation, would use cryptographically secure random generation
        return "token_" + deviceId + "_" + now().toText();
    };
};

/**
 * Customer Assignment Protocol
 * Manages the relationship between a device and customers
 */
@api
protocol[sys_admin, tenant_admin] CustomerAssignment(var deviceId: Text) {
    
    initial state unassigned;
    state assigned;
    state claimed;
    
    private var customerId: Optional<Text> = optionalOf<Text>();
    private var claimedBy: Optional<Text> = optionalOf<Text>();
    
    /**
     * Assign device to customer
     */
    @api
    permission[sys_admin | tenant_admin] assignToCustomer(newCustomerId: Text) | unassigned {
        require(newCustomerId.length() > 0, "Customer ID cannot be empty");
        
        customerId = optionalOf(newCustomerId);
        notify deviceAssigned(deviceId, newCustomerId);
        become assigned;
    };
    
    /**
     * Unassign device from customer
     */
    @api
    permission[sys_admin | tenant_admin] unassignFromCustomer() | assigned {
        var oldCustomerId = customerId.getOrFail();
        customerId = optionalOf<Text>();
        notify deviceUnassigned(deviceId);
        become unassigned;
    };
    
    /**
     * Claim device (customer takes ownership)
     */
    @api
    permission[sys_admin | tenant_admin] claimDevice(claimerId: Text) | assigned {
        require(claimerId.length() > 0, "Claimer ID cannot be empty");
        
        claimedBy = optionalOf(claimerId);
        notify deviceClaimed(deviceId, claimerId);
        become claimed;
    };
    
    /**
     * Reclaim device (remove customer ownership)
     */
    @api
    permission[sys_admin | tenant_admin] reclaimDevice(reclaimerId: Text) | claimed {
        require(reclaimerId.length() > 0, "Reclaimer ID cannot be empty");
        
        claimedBy = optionalOf<Text>();
        notify deviceReclaimed(deviceId, reclaimerId);
        become assigned;
    };
    
    /**
     * Get current customer assignment
     */
    @api
    permission[sys_admin | tenant_admin] getCurrentCustomer() returns Optional<Text> {
        return customerId;
    };
    
    /**
     * Get current customer for device record
     */
    @api
    permission[sys_admin | tenant_admin] getCustomerIdForDevice() returns Optional<Text> {
        return customerId;
    };
};

/**
 * Edge Assignment Protocol  
 * Manages device assignments to edge instances
 */
@api
protocol[sys_admin, tenant_admin] EdgeAssignment(var deviceId: Text) {
    
    initial state unassigned;
    state assigned;
    
    private var edgeId: Optional<Text> = optionalOf<Text>();
    
    /**
     * Assign device to edge
     */
    @api
    permission[sys_admin | tenant_admin] assignToEdge(newEdgeId: Text) | unassigned {
        require(newEdgeId.length() > 0, "Edge ID cannot be empty");
        
        edgeId = optionalOf(newEdgeId);
        notify deviceAssignedToEdge(deviceId, newEdgeId);
        become assigned;
    };
    
    /**
     * Unassign device from edge
     */
    @api
    permission[sys_admin | tenant_admin] unassignFromEdge() | assigned {
        var oldEdgeId = edgeId.getOrFail();
        edgeId = optionalOf<Text>();
        notify deviceUnassignedFromEdge(deviceId, oldEdgeId);
        become unassigned;
    };
    
    /**
     * Get current edge assignment
     */
    @api
    permission[sys_admin | tenant_admin] getCurrentEdge() returns Optional<Text> {
        return edgeId;
    };
};

// ========== MAIN DEVICE MANAGEMENT PROTOCOL ==========

/**
 * Main Device Management Protocol
 * Orchestrates device lifecycle using composed protocols
 */
@api
protocol[sys_admin, tenant_admin, customer_user] DeviceManagement() {

    initial state active;
    
    // Core device storage
    private var devices = mapOf<Text, Device>();
    
    // Composed protocol instances for each device
    private var deviceCredentials = mapOf<Text, DeviceCredentialsManager>();
    private var customerAssignments = mapOf<Text, CustomerAssignment>();
    private var edgeAssignments = mapOf<Text, EdgeAssignment>();
    
    // Advanced protocols (shared instances)
    var validationRules: DeviceValidationRules = DeviceValidationRules[sys_admin, tenant_admin]();
    var bulkImportTrackers: Map<Text, BulkImportProgress> = mapOf<Text, BulkImportProgress>();

    /**
     * Validate device data
     */
    function validateDevice(device: Device) returns Boolean -> {
        if (device.name.length() == 0) {
            return false;
        };
        if (device.type.length() == 0) {
            return false;
        };
        if (device.tenantId.length() == 0) {
            return false;
        };
        if (device.name.length() > 255) {
            return false;
        };
        return true;
    };

    /**
     * Create or update a device with composed protocol creation
     */
    @api
    permission[sys_admin | tenant_admin] saveDevice(device: Device) returns Device | active {
        require(validateDevice(device), "Device validation failed");
        
        var isNewDevice = !devices.getOrNone(device.id).isPresent();
        
        // Create composed protocols for new devices
        if (isNewDevice) {
            var credentials = DeviceCredentialsManager[sys_admin, tenant_admin](device.id);
            var customerAssignment = CustomerAssignment[sys_admin, tenant_admin](device.id);
            var edgeAssignment = EdgeAssignment[sys_admin, tenant_admin](device.id);
            
            deviceCredentials = deviceCredentials.with(device.id, credentials);
            customerAssignments = customerAssignments.with(device.id, customerAssignment);
            edgeAssignments = edgeAssignments.with(device.id, edgeAssignment);
        };
        
        // Get credentials value from composed protocol
        var credentialsValue = "";
        var credentialsProtocol = deviceCredentials.getOrNone(device.id);
        if (credentialsProtocol.isPresent()) {
            credentialsValue = credentialsProtocol.getOrFail().getCredentialsValue[sys_admin]();
        };
        
        // Get customer assignment from composed protocol
        var customerIdForDevice = optionalOf<Text>();
        var customerProtocol = customerAssignments.getOrNone(device.id);
        if (customerProtocol.isPresent()) {
            customerIdForDevice = customerProtocol.getOrFail().getCustomerIdForDevice[sys_admin]();
        };
        
        var deviceToSave = Device(
            id = device.id,
            name = device.name,
            type = device.type,
            tenantId = device.tenantId,
            customerId = customerIdForDevice,
            credentials = credentialsValue,
            label = device.label,
            deviceProfileId = device.deviceProfileId,
            firmwareId = device.firmwareId,
            softwareId = device.softwareId,
            externalId = device.externalId,
            version = device.version,
            additionalInfo = device.additionalInfo,
            createdTime = optionalOf(1234567890),
            deviceData = device.deviceData
        );
        
        this.devices = this.devices.with(deviceToSave.id, deviceToSave);
        notify deviceSaved(deviceToSave);
        return deviceToSave;
    };

    /**
     * Get device by ID
     */
    @api
    permission[sys_admin | tenant_admin | customer_user] getDeviceById(id: Text) returns Optional<Device> | active {
        return devices.getOrNone(id);
    };

    /**
     * Delete device with composed protocol cleanup
     */
    @api
    permission[sys_admin | tenant_admin] deleteDevice(id: Text) | active {
        var device = devices.getOrNone(id);
        require(device.isPresent(), "Device not found");
        
        // Clean up composed protocols
        var credentialsProtocol = deviceCredentials.getOrNone(id);
        if (credentialsProtocol.isPresent()) {
            credentialsProtocol.getOrFail().deleteCredentials[sys_admin]();
        };
        
        // Remove protocol instances
        deviceCredentials = deviceCredentials.without(id);
        customerAssignments = customerAssignments.without(id);
        edgeAssignments = edgeAssignments.without(id);
        devices = devices.without(id);
        
        notify deviceDeleted(id);
    };

    /**
     * Assign device to customer using composed protocol
     */
    @api
    permission[sys_admin | tenant_admin] assignDeviceToCustomer(deviceId: Text, customerId: Text) | active {
        var device = devices.getOrNone(deviceId);
        require(device.isPresent(), "Device not found");
        
        var customerAssignment = customerAssignments.getOrNone(deviceId).getOrFail();
        customerAssignment.assignToCustomer[sys_admin](customerId);
        
        // Update device record with new customer assignment
        var updatedDevice = Device(
            id = device.getOrFail().id,
            name = device.getOrFail().name,
            type = device.getOrFail().type,
            tenantId = device.getOrFail().tenantId,
            customerId = optionalOf(customerId),
            credentials = device.getOrFail().credentials,
            label = device.getOrFail().label,
            deviceProfileId = device.getOrFail().deviceProfileId,
            firmwareId = device.getOrFail().firmwareId,
            softwareId = device.getOrFail().softwareId,
            externalId = device.getOrFail().externalId,
            version = device.getOrFail().version,
            additionalInfo = device.getOrFail().additionalInfo,
            createdTime = device.getOrFail().createdTime,
            deviceData = device.getOrFail().deviceData
        );
        devices = devices.with(deviceId, updatedDevice);
    };

    /**
     * Unassign device from customer using composed protocol
     */
    @api
    permission[sys_admin | tenant_admin] unassignDeviceFromCustomer(deviceId: Text) | active {
        var device = devices.getOrNone(deviceId);
        require(device.isPresent(), "Device not found");
        
        var customerAssignment = customerAssignments.getOrNone(deviceId).getOrFail();
        customerAssignment.unassignFromCustomer[sys_admin]();
        
        // Update device record
        var updatedDevice = Device(
            id = device.getOrFail().id,
            name = device.getOrFail().name,
            type = device.getOrFail().type,
            tenantId = device.getOrFail().tenantId,
            customerId = optionalOf<Text>(),
            credentials = device.getOrFail().credentials,
            label = device.getOrFail().label,
            deviceProfileId = device.getOrFail().deviceProfileId,
            firmwareId = device.getOrFail().firmwareId,
            softwareId = device.getOrFail().softwareId,
            externalId = device.getOrFail().externalId,
            version = device.getOrFail().version,
            additionalInfo = device.getOrFail().additionalInfo,
            createdTime = device.getOrFail().createdTime,
            deviceData = device.getOrFail().deviceData
        );
        devices = devices.with(deviceId, updatedDevice);
    };

    /**
     * Save device credentials using composed protocol
     */
    @api
    permission[sys_admin | tenant_admin] saveDeviceCredentials(deviceId: Text, credentials: DeviceCredentials) | active {
        var device = devices.getOrNone(deviceId);
        require(device.isPresent(), "Device not found");
        
        var credentialsProtocol = deviceCredentials.getOrNone(deviceId).getOrFail();
        credentialsProtocol.updateCredentials[sys_admin](
            credentials.credentialsType, 
            credentials.credentialsId, 
            credentials.credentialsValue,
            credentials.expirationTime,
            credentials.autoRotate.getOrElse(false)
        );
        
        // Update device record with new credentials
        var updatedDevice = Device(
            id = device.getOrFail().id,
            name = device.getOrFail().name,
            type = device.getOrFail().type,
            tenantId = device.getOrFail().tenantId,
            customerId = device.getOrFail().customerId,
            credentials = credentials.credentialsValue,
            label = device.getOrFail().label,
            deviceProfileId = device.getOrFail().deviceProfileId,
            firmwareId = device.getOrFail().firmwareId,
            softwareId = device.getOrFail().softwareId,
            externalId = device.getOrFail().externalId,
            version = device.getOrFail().version,
            additionalInfo = device.getOrFail().additionalInfo,
            createdTime = device.getOrFail().createdTime,
            deviceData = device.getOrFail().deviceData
        );
        devices = devices.with(deviceId, updatedDevice);
    };

    /**
     * Delete device credentials using composed protocol
     */
    @api
    permission[sys_admin | tenant_admin] deleteDeviceCredentials(deviceId: Text) | active {
        var device = devices.getOrNone(deviceId);
        require(device.isPresent(), "Device not found");
        
        var credentialsProtocol = deviceCredentials.getOrNone(deviceId).getOrFail();
        credentialsProtocol.deleteCredentials[sys_admin]();
    };

    /**
     * Claim device using composed protocol
     */
    @api
    permission[sys_admin | tenant_admin] claimDevice(deviceId: Text) | active {
        var device = devices.getOrNone(deviceId);
        require(device.isPresent(), "Device not found");
        
        var customerAssignment = customerAssignments.getOrNone(deviceId).getOrFail();
        customerAssignment.claimDevice[sys_admin]("current_user");
    };

    /**
     * Reclaim device using composed protocol
     */
    @api
    permission[sys_admin | tenant_admin] reclaimDevice(deviceId: Text) | active {
        var device = devices.getOrNone(deviceId);
        require(device.isPresent(), "Device not found");
        
        var customerAssignment = customerAssignments.getOrNone(deviceId).getOrFail();
        customerAssignment.reclaimDevice[sys_admin]("current_user");
    };

    /**
     * Assign device to edge using composed protocol
     */
    @api
    permission[sys_admin | tenant_admin] assignDeviceToEdge(deviceId: Text, edgeId: Text) | active {
        var device = devices.getOrNone(deviceId);
        require(device.isPresent(), "Device not found");
        
        var edgeAssignment = edgeAssignments.getOrNone(deviceId).getOrFail();
        edgeAssignment.assignToEdge[sys_admin](edgeId);
    };

    /**
     * Unassign device from edge using composed protocol
     */
    @api
    permission[sys_admin | tenant_admin] unassignDeviceFromEdge(deviceId: Text, edgeId: Text) | active {
        var device = devices.getOrNone(deviceId);
        require(device.isPresent(), "Device not found");
        
        var edgeAssignment = edgeAssignments.getOrNone(deviceId).getOrFail();
        edgeAssignment.unassignFromEdge[sys_admin]();
    };

    /**
     * Get device credentials using composed protocol
     */
    @api
    permission[sys_admin | tenant_admin] getDeviceCredentials(deviceId: Text) returns Optional<DeviceCredentials> | active {
        var device = devices.getOrNone(deviceId);
        require(device.isPresent(), "Device not found");
        
        var credentialsProtocol = deviceCredentials.getOrNone(deviceId);
        if (credentialsProtocol.isPresent()) {
            return optionalOf(credentialsProtocol.getOrFail().getCredentials[sys_admin]());
        };
        
        return optionalOf<DeviceCredentials>();
    };

    /**
     * Get customer devices using composed protocols
     */
    @api
    permission[sys_admin | tenant_admin | customer_user] getCustomerDevices(customerId: Text) returns List<Device> | active {
        var customerDevices = listOf<Device>();
        var allDevices = devices.values();
        
        for (device in allDevices) {
            var customerAssignment = customerAssignments.getOrNone(device.id);
            if (customerAssignment.isPresent()) {
                var assignedCustomer = customerAssignment.getOrFail().getCurrentCustomer[sys_admin]();
                if (assignedCustomer.isPresent() && assignedCustomer.getOrFail() == customerId) {
                    customerDevices = customerDevices.with(device);
                };
            };
        };
        
        return customerDevices;
    };

    /**
     * Get all devices
     */
    @api
    permission[sys_admin | tenant_admin | customer_user] getAllDevices() returns List<Device> | active {
        return devices.values();
    };

    /**
     * Create device with credentials using protocol composition
     */
    @api
    permission[sys_admin | tenant_admin] saveDeviceWithCredentials(request: SaveDeviceWithCredentialsRequest) returns Device | active {
        require(validateDevice(request.device), "Device validation failed");
        require(request.credentials.credentialsType.length() > 0, "Credentials type cannot be empty");
        
        // Implement device creation directly to avoid recursive call
        var device = request.device;
        var isNewDevice = !devices.getOrNone(device.id).isPresent();
        
        // Create composed protocols for new devices
        if (isNewDevice) {
            var credentials = DeviceCredentialsManager[sys_admin, tenant_admin](device.id);
            var customerAssignment = CustomerAssignment[sys_admin, tenant_admin](device.id);
            var edgeAssignment = EdgeAssignment[sys_admin, tenant_admin](device.id);
            
            deviceCredentials = deviceCredentials.with(device.id, credentials);
            customerAssignments = customerAssignments.with(device.id, customerAssignment);
            edgeAssignments = edgeAssignments.with(device.id, edgeAssignment);
        };
        
        // Get credentials value from composed protocol
        var credentialsValue = request.credentials.credentialsValue;
        var credentialsProtocol = deviceCredentials.getOrNone(device.id);
        if (credentialsProtocol.isPresent()) {
            credentialsProtocol.getOrFail().updateCredentials[sys_admin](
                request.credentials.credentialsType, 
                request.credentials.credentialsId, 
                request.credentials.credentialsValue,
                request.credentials.expirationTime,
                request.credentials.autoRotate.getOrElse(false)
            );
            credentialsValue = credentialsProtocol.getOrFail().getCredentialsValue[sys_admin]();
        };
        
        var deviceToSave = Device(
            id = device.id,
            name = device.name,
            type = device.type,
            tenantId = device.tenantId,
            customerId = device.customerId,
            credentials = credentialsValue,
            label = device.label,
            deviceProfileId = device.deviceProfileId,
            firmwareId = device.firmwareId,
            softwareId = device.softwareId,
            externalId = device.externalId,
            version = device.version,
            additionalInfo = device.additionalInfo,
            createdTime = optionalOf(1234567890),
            deviceData = device.deviceData
        );
        
        this.devices = this.devices.with(deviceToSave.id, deviceToSave);
        
        notify deviceSaved(deviceToSave);
        return deviceToSave;
    };

    // ========== ENHANCED BULK OPERATIONS ==========

    /**
     * Start bulk device import with state-based progress tracking
     */
    @api
    permission[sys_admin | tenant_admin] startBulkDeviceImport(
        devices: List<Device>,
        validateOnly: Boolean
    ) returns Text | active {
        
        var importId = "import_" + now().toText();
        var progressTracker = BulkImportProgress[sys_admin, tenant_admin](importId);
        
        bulkImportTrackers = bulkImportTrackers.with(importId, progressTracker);
        progressTracker.initializeImport[sys_admin](devices.size());
        
        // Start validation phase
        progressTracker.startValidation[sys_admin]();
        
        var successCount = 0;
        var failedCount = 0;
        
        // Validation phase with progress updates
        for (device in devices) {
            var validation = validationRules.validateDevice[sys_admin](device, "CREATE", this.devices.size());
            if (!validation.isValid) {
                var errorMsg = if (validation.errors.isEmpty()) { "Validation failed"; } else { validation.errors.get(0); };
                progressTracker.updateProgress[sys_admin](device.name, false, optionalOf(errorMsg));
                failedCount = failedCount + 1;
            } else {
                progressTracker.updateProgress[sys_admin](device.name, true, optionalOf<Text>());
                successCount = successCount + 1;
            };
        };
        
        if (!validateOnly) {
            progressTracker.startProcessing[sys_admin]();
            
            // Processing phase
            for (device in devices) {
                var validation = validationRules.validateDevice[sys_admin](device, "CREATE", this.devices.size());
                if (validation.isValid) {
                    // Create device directly instead of recursive call
                    var deviceToSave = Device(
                        id = device.id,
                        name = device.name,
                        type = device.type,
                        tenantId = device.tenantId,
                        customerId = device.customerId,
                        credentials = "",
                        label = device.label,
                        deviceProfileId = device.deviceProfileId,
                        firmwareId = device.firmwareId,
                        softwareId = device.softwareId,
                        externalId = device.externalId,
                        version = device.version,
                        additionalInfo = device.additionalInfo,
                        createdTime = optionalOf(1234567890),
                        deviceData = device.deviceData
                    );
                    
                    this.devices = this.devices.with(deviceToSave.id, deviceToSave);
                    notify deviceSaved(deviceToSave);
                    progressTracker.updateProgress[sys_admin](device.name, true, optionalOf<Text>());
                };
            };
        };
        
        return importId;
    };
    
    /**
     * Get bulk import progress status
     */
    @api
    permission[sys_admin | tenant_admin | customer_user] getBulkImportProgress(
        importId: Text
    ) returns Optional<BulkImportStatus> | active {
        var progressTracker = bulkImportTrackers.getOrNone(importId);
        if (progressTracker.isPresent()) {
            return optionalOf(progressTracker.getOrFail().getProgress[sys_admin]());
        };
        return optionalOf<BulkImportStatus>();
    };
    
    /**
     * Enhanced bulk update with validation
     */
    @api
    permission[sys_admin | tenant_admin] bulkUpdateDevices(
        deviceIds: List<Text>, 
        updates: DeviceUpdateSet
    ) returns BulkImportResult | active {
        var importId = "bulk_update_" + now().toText();
        var startTime = 1234567890;
        
        var successCount = 0;
        var failedCount = 0;
        var errors = listOf<Text>();
        var warnings = listOf<Text>();
        
        for (deviceId in deviceIds) {
            var device = devices.getOrNone(deviceId);
            
            if (!device.isPresent()) {
                failedCount = failedCount + 1;
                errors = errors.with("Device not found: " + deviceId);
            } else {
                var existingDevice = device.getOrFail();
                var updatedDevice = applyDeviceUpdates(existingDevice, updates);
                
                // Validate updated device
                var validation = validationRules.validateDevice[sys_admin](updatedDevice, "UPDATE", devices.size());
                
                if (!validation.isValid) {
                    failedCount = failedCount + 1;
                    var errorMsg = if (validation.errors.isEmpty()) { "Validation failed"; } else { validation.errors.get(0); };
                    errors = errors.with("Device " + deviceId + ": " + errorMsg);
                } else {
                    devices = devices.with(deviceId, updatedDevice);
                    successCount = successCount + 1;
                    for (warning in validation.warnings) {
                        warnings = warnings.with(warning);
                    };
                    notify deviceSaved(updatedDevice);
                };
            };
        };
        
        var endTime = 1234567890;
        var processingTime = endTime - startTime;
        
        var result = BulkImportResult(
            totalProcessed = deviceIds.size(),
            successCount = successCount,
            failedCount = failedCount,
            skippedCount = 0,
            errors = errors,
            warnings = warnings,
            importId = importId,
            processingTime = processingTime
        );
        
        notify devicesBulkUpdated(successCount, failedCount);
        return result;
    };
    
    // Helper function for applying device updates
    function applyDeviceUpdates(device: Device, updates: DeviceUpdateSet) returns Device -> {
        var updatedLabel = device.label;
        if (updates.label.isPresent()) {
            updatedLabel = updates.label;
        };
        
        var updatedType = device.type;
        if (updates.type.isPresent()) {
            updatedType = updates.type.getOrFail();
        };
        
        var updatedProfileId = device.deviceProfileId;
        if (updates.deviceProfileId.isPresent()) {
            updatedProfileId = updates.deviceProfileId;
        };
        
        var updatedAdditionalInfo = device.additionalInfo;
        if (updates.additionalInfo.isPresent()) {
            updatedAdditionalInfo = updates.additionalInfo;
        };
        
        return Device(
            id = device.id,
            name = device.name,
            type = updatedType,
            tenantId = device.tenantId,
            customerId = device.customerId,
            credentials = device.credentials,
            label = updatedLabel,
            deviceProfileId = updatedProfileId,
            firmwareId = device.firmwareId,
            softwareId = device.softwareId,
            externalId = device.externalId,
            version = device.version,
            additionalInfo = updatedAdditionalInfo,
            createdTime = device.createdTime,
            deviceData = device.deviceData
        );
    };

    // ========== EXISTING BULK OPERATIONS ==========

    /**
     * Process bulk device import
     */
    @api
    permission[sys_admin | tenant_admin] processDevicesBulkImport(deviceData: Text) returns BulkImportResult | active {
        var successCount = 1;
        var failedCount = 0;
        var errors = listOf<Text>();
        
        notify devicesBulkImported(successCount, failedCount, "import_123"); // Placeholder importId
        notify bulkImportStarted("import_123");
        notify bulkImportInitialized("import_123", 10);
        notify bulkImportValidationStarted("import_123");
        notify bulkImportProcessingStarted("import_123");
        notify bulkImportProgressUpdated("import_123", 1, 10, true);
        notify bulkImportCompleted("import_123", 1, 0);
        
        return BulkImportResult(
            totalProcessed = 1,
            successCount = successCount,
            failedCount = failedCount,
            skippedCount = 0,
            errors = errors,
            warnings = listOf<Text>(),
            importId = "import_123",
            processingTime = 0
        );
    };

    /**
     * Process bulk device deletion
     */
    @api
    permission[sys_admin | tenant_admin] processDevicesBulkDelete(deviceIds: List<Text>) returns BulkImportResult | active {
        var deletedCount = 0;
        var failedCount = 0;
        var errors = listOf<Text>();
        
        for (deviceId in deviceIds) {
            var device = devices.getOrNone(deviceId);
            if (device.isPresent()) {
                // Implement deletion logic directly to avoid recursive call
                
                // Clean up composed protocols
                var credentialsProtocol = deviceCredentials.getOrNone(deviceId);
                if (credentialsProtocol.isPresent()) {
                    credentialsProtocol.getOrFail().deleteCredentials[sys_admin]();
                };
                
                // Remove protocol instances
                deviceCredentials = deviceCredentials.without(deviceId);
                customerAssignments = customerAssignments.without(deviceId);
                edgeAssignments = edgeAssignments.without(deviceId);
                devices = devices.without(deviceId);
                
                notify deviceDeleted(deviceId);
                deletedCount = deletedCount + 1;
            } else {
                failedCount = failedCount + 1;
                errors = errors.with("Device not found: " + deviceId);
            };
        };
        
        notify devicesBulkDeleted(deletedCount, failedCount);
        
        return BulkImportResult(
            totalProcessed = deviceIds.size(),
            successCount = deletedCount,
            failedCount = failedCount,
            skippedCount = 0,
            errors = errors,
            warnings = listOf<Text>(),
            importId = "delete_" + now().toText(),
            processingTime = 0
        );
    };

}; 